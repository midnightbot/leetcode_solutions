##ss
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        
        
        ## node1+----+node2   node3
        
        ##node1       node2     node3
        
        ## node1 - node2 - node3
        
        ##find spread of each initial node
        ## say we have 3 initial nodes 0,1,2
        ## so for if we remove node0 -> cover will be spread[1] union spread[2]
        ##remove node1 -> cover will be spread[0] union spread[2]
        ## remove node2 -> cover will be spread[0] union spread[1]
        
        ## return the node which minimizes such cover
        
        #parent = [-1 for x in range(len(graph))]
        self.spread = {}
        self.size = {}
        
        
        ## [node, parent]
        initial = sorted(initial)
        for x in range(len(initial)):
            self.do_bfs(graph,initial[x])
            
        maxs = -float('inf')
        result = -1
        #print(self.size)
        for x in self.size:
            for y in range(len(graph[x])):
                if graph[x][y] == 1:
                    self.size[x]-=1
                    
        
        #result = -1
        mins = float('inf')
        result = -1
        
        q = []
        for x in self.spread:
            q.append([x,self.spread[x]])
            
        for x in range(len(q)):
            thisspread = set()
            for y in range(len(q)):
                if x!=y:
                    thisspread = thisspread.union(q[y][1])
                    
            if len(thisspread) < mins:
                mins = len(thisspread)
                result = q[x][0]
                
        return result
        
    def do_bfs(self,graph,init):
        
        par = copy.deepcopy(init)
        q = [init]
        count = 0
        visited = set()
        while q:
            node = q.pop(0)
            
            
            visited.add(node)
            count+=1
            if par not in self.spread:
                self.spread[init] = {node}
            else:
                self.spread[init].add(node)
            for z in range(len(graph[node])):
                if graph[node][z] == 1 and z not in visited:
                    q.append(z)
                    visited.add(z)
                    
        self.size[par] = count
                        
